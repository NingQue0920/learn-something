### 进程通信的几种方式
- 管道（pipe）：`ps -ef | grep python` 中符号'|'表示管道，用于将进程A（ps）的输出，传递给进程B（grep）。 
  - 管道分匿名管道和命名管道两种。
  - 匿名管道只能应用与存在血缘关系的进程之间的数据传递，如父子进程、兄弟进程；`| `属于匿名管道。
  - 命名管道可以应用于任何两个进程之间的数据传递。
  - 管道本质上也是一个文件，但对该文件的写入操作并不会真正写入磁盘，而是写入到文件缓冲区中。因此，管道占用的是内存空间而非磁盘空间。
  - 管道是单向的，如果进程A以只写方式打开管道，则进程B只能以只读方式打开管道。
  - 管道传输的是字节流。
  - 工作原理：创建2个文件描述符fd[0]和fd[1]，分别用于读和写，pipe_write函数用于将数据复制到缓冲区，pipe_read函数用于从缓冲区复制数据到用户空间中。
- 信号（Signal）：`kill -9 <pid> ` 就是一个信号，通过键盘敲击`ctrl+c`实现终止操作本质上也是一个信号。
  - 可以通过`kill -l` 列出Linux支持的所有信号，以及它们的含义。
  - 每个信号都有自己的默认含义，也可以自定义信号处理函数，来改变其默认行为。
  - 当进程收到信号后，便会执行该信号的默认行为，如 `kill -9 <pid>` 会产生SIGKILL信号，此时操作系统会立刻终止该进程并释放资源。
- 消息队列（Message Queue）：类似于消息中间件中的消息队列，用于进程之间传输更多的数据，但实时性受限。
  - 对应的内核结构体是`struct msg_queue` ，本质上是一个链表。在使用时，由内核开辟一块内存空间存放这个链表，发送数据时，会向链表中添加一个节点；接收数据时，从链表中删除一个节点。
- 信号量（Semaphore）：本质上是一种锁，当某个信号量已经被占用时，其他进程尝试获取会被阻塞。相较于**通信**，个人更倾向于**同步**这个概念。
  - 对应的结构体是`struct semaphore`，包含三个字段，分别是`lock`，`count`和`waitlist`；表示锁、计数器和等待队列。
  - 工作原理与锁类似，初始化count计数器，获取信号量时，如果count计数器大于0，就将count计数器减1，否则就阻塞等待。整个过程会使用lock进行锁定，保证并发安全。
- 共享内存（Shared Memory）：把一个共享的文件映射到自己的进程地址空间中，从而实现对该文件的多进程访问。是最快的一种通信方式。
  - Linux中每个进程都有属于自己的地址空间（Addr Space）；通过页表将虚拟地址和物理地址进行映射，并通过MMU去管理。
  - 两个或多个虚拟地址通过页表映射到同一个物理地址，则这块物理地址空间即为共享内存。
- 套接字（Socket）：严格来说是IPC Socket（本地套接字），本机进程通信时，不需要经过网络协议栈的封装、打包拆包、校验和等操作，仅将应用层数据从进程A复制到进程B即可。
  - 工作过程与Socket类似，但是在/tmp目录下临时生成一个socket文件，用于数据的传输。

参考：https://cloud.tencent.com/developer/article/2439262